<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Securiy Blog</title>
    <link>https://yoavshah.github.io/</link>
    <description>Recent content on Securiy Blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 16 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://yoavshah.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0-setting_up_environment</title>
      <link>https://yoavshah.github.io/blockchain/development/0-setting_up_environment/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/blockchain/development/0-setting_up_environment/</guid>
      <description>Here I will explain how to set up the enviornment for the development of smart contracts&#xA;Setting Up the Enviornment In this tutorial we will use hardhat.&#xA;We first can create a project using the following command and choose our option&#xA;npx hardhat init&#xD;In the initialization we get an example of smart contract called Lock.sol and many other files.&#xA;In the contracts folder, there is all the code for our smart contract.</description>
    </item>
    <item>
      <title>0-setting_up_environment</title>
      <link>https://yoavshah.github.io/blockchain/ethernaut/0-setting_up_environment/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/blockchain/ethernaut/0-setting_up_environment/</guid>
      <description>Here I will explain how to set up the enviornment for the research&#xA;Setting Up the Enviornment </description>
    </item>
    <item>
      <title>1-KingOfTheHill</title>
      <link>https://yoavshah.github.io/blockchain/development/1-kingofthehill/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/blockchain/development/1-kingofthehill/</guid>
      <description>Why? I learned about Ethereum and how it works and I wanted to try to interact with it. I decided to create a simple smart contract.&#xA;What? The smart contract I decided to create is a &amp;ldquo;KingOfTheHill&amp;rdquo; donation smart contract. The contract gets donations and saves each address, the amount of the donations it sent, and a message of this address.&#xA;Addresses can interact with the smart contract by:&#xA;sending donations (payments) getting the &amp;ldquo;King&amp;rdquo; address and its info (The &amp;ldquo;King&amp;rdquo; address is the one who donated the most amount of Ether) getting the current address info (amount donated, message) setting the message of the current address The Owner of the contract can withdraw the donations at anytime</description>
    </item>
    <item>
      <title>Reverse RTCore64</title>
      <link>https://yoavshah.github.io/windows/kernel/reverse_rtcore64/</link>
      <pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/windows/kernel/reverse_rtcore64/</guid>
      <description>Here I will show the reversing process of RTCore64.sys I first recommend going through reverse_dbutil_2_3.&#xA;DriverEntry A very easy DriverEntry, all it does is to create a device driver and a symbolic link, later setting the Major functions&#xA;NTSTATUS __stdcall DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) { NTSTATUS result; // eax PDEVICE_OBJECT DeviceObject; // [rsp+40h] [rbp-38h] BYREF _UNICODE_STRING DestinationString; // [rsp+48h] [rbp-30h] BYREF _UNICODE_STRING SymbolicLinkName; // [rsp+58h] [rbp-20h] BYREF RtlInitUnicodeString(&amp;amp;DestinationString, aDeviceRtcore64); RtlInitUnicodeString(&amp;amp;SymbolicLinkName, SourceString); result = IoCreateDevice(DriverObject, 0, &amp;amp;DestinationString, 0x22u, 0, 0, &amp;amp;DeviceObject); if ( result &amp;gt;= 0 ) { result = IoCreateSymbolicLink(&amp;amp;SymbolicLinkName, &amp;amp;DestinationString); if ( result &amp;gt;= 0 ) { DriverObject-&amp;gt;MajorFunction[0] = GenericMajor; DriverObject-&amp;gt;MajorFunction[2] = GenericMajor; DriverObject-&amp;gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = GenericMajor; DriverObject-&amp;gt;DriverUnload = (PDRIVER_UNLOAD)sub_11000; return 0; } } return result; }&#xD;GenericMajor NTSTATUS __stdcall GenericMajor(_DEVICE_OBJECT *DeviceObject, _IRP *Irp) { _IO_STACK_LOCATION *CurrentStackLocation; // rax _IRP *SystemBuffer; // r10 __int64 SystemBufferInputLength; // rdx __int64 SystemBufferOutputLength; // r9 PMDL v7; // rcx PMDL v8; // rdx NTSTATUS v9; // eax PMDL MdlAddress; // rcx NTSTATUS v11; // eax char v12; // al unsigned __int16 v13; // ax unsigned __int32 v14; // eax __int64 v15; // r10 unsigned __int16 *v16; // r10 __int64 v17; // r10 int v18; // ecx ULONG Length; // ecx ULONG Flags; // ecx ULONG Offset; // edx NTSTATUS Status; // ebx unsigned __int64 v24; // [rsp+30h] [rbp-28h] Irp-&amp;gt;IoStatus.</description>
    </item>
    <item>
      <title>Read/Write using dbutil_2_3</title>
      <link>https://yoavshah.github.io/windows/kernel/readwrite_using_dbutil_2_3/</link>
      <pubDate>Wed, 07 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/windows/kernel/readwrite_using_dbutil_2_3/</guid>
      <description>This article is the second article about dbutil_2_3.sys, in this one I will exploit the vulnerabilities in this driver to gain priviledges in the computer We will use the following IOCTLs which allow us to read and write memory to any location in the kernel.&#xA;Architecture I will first create a class called DBUtilInterface which will have the functionality we need for the driver.&#xA;class DBUtilInterface { private: HANDLE device_handle; public: DBUtilInterface(); ~DBUtilInterface(); bool read_kernel_memory(void* dst, void* src, unsigned int size); bool write_kernel_memory(void* dst, void* src, unsigned int size); };&#xD;Constructor We want that in the constructor of the class a new handle to the device driver will be open</description>
    </item>
    <item>
      <title>FileInfector</title>
      <link>https://yoavshah.github.io/windows/portable-executable/fileinfector/</link>
      <pubDate>Mon, 24 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/windows/portable-executable/fileinfector/</guid>
      <description></description>
    </item>
    <item>
      <title>0-rsa_explained</title>
      <link>https://yoavshah.github.io/cryptohack/rsa/0-rsa_explained/</link>
      <pubDate>Tue, 18 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/rsa/0-rsa_explained/</guid>
      <description>Here I will explain RSA&#xA;RSA RSA is an asymmetric encryption algorithm with a public key and a private key. The key generation follows&#xA;Choose $p$ and $q$ large prime numbers. Calculate $N = p * q$. Calculate the Euler&amp;rsquo;s totient function of $N$, because $N$ is multiplication of 2 prime numbers, $\varphi(N) = \varphi(p) * \varphi(q) = (p - 1) * (q - 1)$. Choose exponent $e$. Calculate the inverse of $e$ in $\varphi(N)$ ring (There is an inverse only if $GCD(e, \varphi(N)) = 1$), let&amp;rsquo;s call it $d$.</description>
    </item>
    <item>
      <title>7-the_matrix</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/7-the_matrix/</link>
      <pubDate>Mon, 03 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/7-the_matrix/</guid>
      <description>Challenge In this challenge we get a python (+ SageMath) code that generates a random matrix (with the flag) and power it by 31337. we get the powered matrix and we need to find the base matrix and extract from it the flag.&#xA;import random P = 2 N = 50 E = 31337 FLAG = b&amp;#39;crypto{??????????????????????????}&amp;#39; def bytes_to_binary(s): bin_str = &amp;#39;&amp;#39;.join(format(b, &amp;#39;08b&amp;#39;) for b in s) bits = [int(c) for c in bin_str] return bits def generate_mat(): while True: msg = bytes_to_binary(FLAG) msg += [random.</description>
    </item>
    <item>
      <title>8-the_matrix_reloaded</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/8-the_matrix_reloaded/</link>
      <pubDate>Mon, 03 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/8-the_matrix_reloaded/</guid>
      <description>Challenge In this challenge we get a matrix called generator, the program creating a random value and calculates $generator^{secret}$, then it creates a random vector $v$ and calculates $w = generator^{secret} * v$&#xA;We get the generator, w, v, and we need to find the secret.&#xA;from Crypto.Cipher import AES from Crypto.Hash import SHA256 from Crypto.Util.number import * from Crypto.Util.Padding import pad, unpad import json from os import urandom FLAG = b&amp;#39;crypto{?</description>
    </item>
    <item>
      <title>9-the_matrix_revolutions</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/9-the_matrix_revolutions/</link>
      <pubDate>Mon, 03 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/9-the_matrix_revolutions/</guid>
      <description>Challenge from Crypto.Cipher import AES from Crypto.Hash import SHA256 from Crypto.Util.number import * from Crypto.Util.Padding import pad, unpad import json from os import urandom FLAG = b&amp;#39;crypto{????????????????????????????????????????}&amp;#39; P = 2 N = 150 def load_matrix(fname): data = open(fname, &amp;#39;r&amp;#39;).read().strip() rows = [list(map(int, row)) for row in data.splitlines()] return Matrix(GF(P), rows) def save_matrix(M, fname): open(fname, &amp;#39;w&amp;#39;).write(&amp;#39;\n&amp;#39;.join(&amp;#39;&amp;#39;.join(str(x) for x in row) for row in M)) KEY_LENGTH = 128 def derive_aes_key(M): mat_str = &amp;#39;&amp;#39;.</description>
    </item>
    <item>
      <title>4-additive</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/4-additive/</link>
      <pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/4-additive/</guid>
      <description>Challenge In this challenge we eavesdrop a converstation between Alice and Bob that use Diffie-Hellman in the key changing but this time they choose to use the operator Add instead of Multiply! What could go wrong :) ?&#xA;Solution Because in normal Diffie-Hellman $$ B = g^b \bmod p $$&#xA;In the Diffie-Hellman in this challenge $$ B = g*b \bmod p $$&#xA;So we could find the inverse of $g$ in $Z_p$ field using the Little Fermat Theorem.</description>
    </item>
    <item>
      <title>5-static_client_2</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/5-static_client_2/</link>
      <pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/5-static_client_2/</guid>
      <description>Challenge In this challenge we get again a converstation of Alice and Bob, we later can exchange keys with Bob. The problem here is that Bob uses the same secret key. The difference between 3-static_client is that Bob now verifies $g$ and verifies $p$.&#xA;Solution To solve this challenge we will generate a new large weak prime number $p$. To make this prime number be weak we need that $\varphi(p)$ will be factored to many small prime numbers.</description>
    </item>
    <item>
      <title>6-script_kiddie</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/6-script_kiddie/</link>
      <pubDate>Wed, 29 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/6-script_kiddie/</guid>
      <description>Challenge In this challenge we get a custom made DH implementation, we need to find weaknesses there.&#xA;from Crypto.Cipher import AES import hashlib import secrets def header(): print(&amp;#34;&amp;#34;&amp;#34; _____ _ __ __ _ | __ \(_)/ _|/ _(_) | | | |_| |_| |_ _ ___ | | | | | _| _| |/ _ \ | |__| | | | | | | | __/ |_____/|_|_| |_| |_|\___| | | | | | | | | |__| | ___| | |_ __ ___ __ _ _ __ | __ |/ _ \ | | &amp;#39;_ ` _ \ / _` | &amp;#39;_ \ | | | | __/ | | | | | | | (_| | | | | |_| |_|\___|_|_|_| |_| |_|\__,_|_| |_| &amp;#34;&amp;#34;&amp;#34;) def is_pkcs7_padded(message): padding = message[-message[-1]:] return all(padding[i] == len(padding) for i in range(0, len(padding))) def pkcs7_unpad(message, block_size=16): if len(message) == 0: raise Exception(&amp;#34;The input data must contain at least one byte&amp;#34;) if not is_pkcs7_padded(message): return message padding_len = message[-1] return message[:-padding_len] def decrypt_flag(shared_secret: int, iv: str, ciphertext: str): # Derive AES key from shared secret sha1 = hashlib.</description>
    </item>
    <item>
      <title>0-diffie_hellman_explained</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/0-diffie_hellman_explained/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/0-diffie_hellman_explained/</guid>
      <description>Here I will explain the Diffie-Hellman algorithm and the discrete log problem!&#xA;Diffie-Hellman In the algorithm first Alice generates ahead of time a prime number p and a generator g.&#xA;Then when Bob starts a converstation with Alice, Alice generates a random value a, calculates A = pow(g, a, p), and then sends to Bob (g, p, A).&#xA;Bob generates a random value b, calculates B = pow(g, b, p), and then sends it to Alice.</description>
    </item>
    <item>
      <title>1-parameter_injection</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/1-parameter_injection/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/1-parameter_injection/</guid>
      <description>Challenge In this challenge we are an attacker sits between Alice and Bob and we perform &amp;ldquo;Man in the Middle&amp;rdquo; attack. We need to get the flag and decrypt it.&#xA;Solution This is an easy challenge, all we need to do is to generate our own b, then the change the message of Bob to contain our B!&#xA;Now Alice will use our B, thus we can calculate the shared_secret by calculating</description>
    </item>
    <item>
      <title>2-export_grade</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/2-export_grade/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/2-export_grade/</guid>
      <description>Challenge In this challenge we are an attacker sits between Alice and Bob and we perform &amp;ldquo;Man in the Middle&amp;rdquo; attack. We cannot change any parameter but the number of bytes chosen and support in the algorithm. Of course we will choose DH-64 bits, but how can we crack it?&#xA;Solution This was quite a hard challenge because I wanted to understand the algorithms used to expolit DH with small keys.</description>
    </item>
    <item>
      <title>3-static_client</title>
      <link>https://yoavshah.github.io/cryptohack/diffie-hellman/3-static_client/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/diffie-hellman/3-static_client/</guid>
      <description>Challenge In this challenge we eavesdropping a session between Alice and Bob, we later can start a new session with Bob.&#xA;Solution The vulnerabillity in this challenge is that Bob reuses his secret key b and that he allows us to choose any p and g .&#xA;At the second part of the call, we can send any g, a, p and Bob will return us B = pow(g, b, p), using that we need to find his secret b.</description>
    </item>
    <item>
      <title>Reverse dbutil_2_3</title>
      <link>https://yoavshah.github.io/windows/kernel/reverse_dbutil_2_3/</link>
      <pubDate>Sat, 25 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/windows/kernel/reverse_dbutil_2_3/</guid>
      <description>Here I will show the reversing process of dbutil_2_3.sys (CVE-2021-21551)&#xA;DriverEntry First have a look at the DriverEntry which is the first function that executes when the driver is loaded&#xA;As we can see, all this function does is to do some sanity checks and then execute sub_11008, let&amp;rsquo;s rename it to RealDriverEntry using the n keyword.&#xA;This is the RealDriverEntry function&#xA;Here we can see the device assosiated with the driver is being created (with undefined priviledges) with the &amp;quot;\Device\DBUtil_2_3&amp;quot; name and with with the symbolic link &amp;quot;\DosDevices\DBUtil_2_3&amp;quot;.</description>
    </item>
    <item>
      <title>1-collider</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/1-collider/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/1-collider/</guid>
      <description>Challenge In this challenge we get a program that stores documents based on their MD5 hash. To get the flag we need to send 2 documents with the same hash.&#xA;import hashlib from utils import listener FLAG = &amp;#34;crypto{???????????????????????????????????}&amp;#34; class Challenge(): def __init__(self): self.before_input = &amp;#34;Give me a document to store\n&amp;#34; self.documents = { &amp;#34;508dcc4dbe9113b15a1f971639b335bd&amp;#34;: b&amp;#34;Particle physics (also known as high energy physics) is a branch of physics that studies the nature of the particles that constitute matter and radiation.</description>
    </item>
    <item>
      <title>2-hash_stuffing</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/2-hash_stuffing/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/2-hash_stuffing/</guid>
      <description>Challenge In this challenge we get a program that creates its own hash algorithm. We need to send two inputs that produce the same hash to gain the flag.&#xA;# 2^128 collision protection! BLOCK_SIZE = 32 # Nothing up my sleeve numbers (ref: Dual_EC_DRBG P-256 coordinates) W = [0x6b17d1f2, 0xe12c4247, 0xf8bce6e5, 0x63a440f2, 0x77037d81, 0x2deb33a0, 0xf4a13945, 0xd898c296] X = [0x4fe342e2, 0xfe1a7f9b, 0x8ee7eb4a, 0x7c0f9e16, 0x2bce3357, 0x6b315ece, 0xcbb64068, 0x37bf51f5] Y = [0xc97445f4, 0x5cdef9f0, 0xd3e05e1e, 0x585fc297, 0x235b82b5, 0xbe8ff3ef, 0xca67c598, 0x52018192] Z = [0xb28ef557, 0xba31dfcb, 0xdd21ac46, 0xe2a91e3c, 0x304f44cb, 0x87058ada, 0x2cb81515, 0x1e610046] # Lets work with bytes instead!</description>
    </item>
    <item>
      <title>3-PriMeD5</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/3-primed5/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/3-primed5/</guid>
      <description>Challenge In this challenge we get a program that allows us to send a prime and sign its hash. Then the program allows us to use the check method, sending a prime, a signature and a number a, then the program validates the signature of the prime, calculates the GCD between the prime and a, then returns the flag based on the GCD between them. The problem is that the GCD between a prime and another number is 1.</description>
    </item>
    <item>
      <title>4-twin_keys</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/4-twin_keys/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/4-twin_keys/</guid>
      <description>Challenge In this challenge we get a program that has a lock, we can set the key and we can try to unlock it. To unlock it we need that some calculation on 2 of our keys will result in the same value. One of the keys must start with &amp;ldquo;CryptoHack Secure Safe&amp;rdquo;, the other mustn&amp;rsquo;t.&#xA;import os import random from Crypto.Hash import MD5 from utils import listener KEY_START = b&amp;#34;CryptoHack Secure Safe&amp;#34; FLAG = b&amp;#34;crypto{?</description>
    </item>
    <item>
      <title>5-no_difference</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/5-no_difference/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/5-no_difference/</guid>
      <description>Challenge In this challenge we get a hash function and we need to find collision in it.&#xA;from utils import listener SBOX = [ 0xf0, 0xf3, 0xf1, 0x69, 0x45, 0xff, 0x2b, 0x4f, 0x63, 0xe1, 0xf3, 0x71, 0x44, 0x1b, 0x35, 0xc8, 0xbe, 0xc0, 0x1a, 0x89, 0xec, 0x3e, 0x1d, 0x3a, 0xe3, 0xbe, 0xd3, 0xcf, 0x20, 0x4e, 0x56, 0x22, 0xe4, 0x43, 0x9a, 0x6f, 0x43, 0xa9, 0x87, 0x37, 0xec, 0x2, 0x3b, 0x8a, 0x7a, 0x13, 0x7e, 0x79, 0xcc, 0x92, 0xd7, 0xd1, 0xff, 0x5e, 0xe2, 0xb1, 0xc9, 0xd3, 0xda, 0x40, 0xfb, 0x80, 0xe6, 0x30, 0x79, 0x1a, 0x28, 0x13, 0x1f, 0x2c, 0x73, 0xb9, 0x71, 0x9e, 0xa6, 0xd5, 0x30, 0x84, 0x9d, 0xa1, 0x9b, 0x6d, 0xf9, 0x8a, 0x3d, 0xe9, 0x47, 0x15, 0x50, 0xb, 0xe2, 0x3d, 0x3f, 0x1, 0x59, 0x9b, 0x85, 0xe4, 0xe5, 0x90, 0xe2, 0x2d, 0x80, 0x5e, 0x6b, 0x77, 0xa1, 0x10, 0x99, 0x72, 0x7f, 0x86, 0x1f, 0x25, 0xa3, 0xea, 0x57, 0x5f, 0xc4, 0xc6, 0x7d, 0x7, 0x15, 0x90, 0xcb, 0x8c, 0xec, 0x11, 0x9b, 0x59, 0x1, 0x3f, 0x3d, 0xe2, 0xb, 0x50, 0x15, 0x47, 0xe9, 0x3d, 0x8a, 0xf9, 0x6d, 0x9b, 0xa1, 0x9d, 0x84, 0x30, 0xd5, 0xa6, 0x9e, 0x71, 0xb9, 0x73, 0x2c, 0x1f, 0x13, 0x28, 0x1a, 0x79, 0x11, 0xec, 0x8c, 0xcb, 0x90, 0x15, 0x7, 0x7d, 0xc6, 0xc4, 0x5f, 0x57, 0xea, 0xa3, 0x25, 0x1f, 0x86, 0x7f, 0x72, 0x99, 0x10, 0xa1, 0x77, 0x6b, 0x5e, 0x80, 0x2d, 0xe2, 0x90, 0xe5, 0xe4, 0x85, 0x22, 0x56, 0x4e, 0x20, 0xcf, 0xd3, 0xbe, 0xe3, 0x3a, 0x1d, 0x3e, 0xec, 0x89, 0x1a, 0xc0, 0xbe, 0xc8, 0x35, 0x1b, 0x44, 0x71, 0xf3, 0xe1, 0x63, 0x4f, 0x2b, 0xff, 0x45, 0x69, 0xf1, 0xf3, 0xf0, 0x30, 0xe6, 0x80, 0xfb, 0x40, 0xda, 0xd3, 0xc9, 0xb1, 0xe2, 0x5e, 0xff, 0xd1, 0xd7, 0x92, 0xcc, 0x79, 0x7e, 0x13, 0x7a, 0x8a, 0x3b, 0x2, 0xec, 0x37, 0x87, 0xa9, 0x43, 0x6f, 0x9a, 0x43, 0xe4, ] FLAG = &amp;#34;crypto{?</description>
    </item>
    <item>
      <title>6-md0</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/6-md0/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/6-md0/</guid>
      <description>Challenge In this challenge we get a hash function that iterates for each block and uses AES-ECB with the current block as its key, then encrypts that last state and xors the encrypted state. To gain the flag we need to sign a message (which just return the hash of the key + the data) and then use the option get_flag with the parameter admin=True and a valid signature.&#xA;from Crypto.</description>
    </item>
    <item>
      <title>7-mdflag</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/7-mdflag/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/7-mdflag/</guid>
      <description>Challenge In this challenge we get a program that have only one option and it is to get data, then xor it together with the flag (cycle - so we can enter more bytes that the flag), the use MD5 on it. We need to somehow get the flag.&#xA;from itertools import cycle from hashlib import md5 import os from utils import listener FLAG = b&amp;#39;crypto{??????????????????????????????????????}&amp;#39; def bxor(a, b): return bytes(x ^ y for x, y in zip(a, b)) class Challenge(): def __init__(self): self.</description>
    </item>
    <item>
      <title>8-mixed_up</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/8-mixed_up/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/8-mixed_up/</guid>
      <description>Challenge In this challenge we get a program that has the option mix which receives data and mix it with the flag&#xA;from hashlib import sha256 import os from utils import listener FLAG = b&amp;#34;crypto{???????????????????????????????}&amp;#34; def _xor(a, b): return bytes([_a ^ _b for _a, _b in zip(a, b)]) def _and(a, b): return bytes([_a &amp;amp; _b for _a, _b in zip(a, b)]) def shuffle(mixed_and, mixed_xor): return bytes([mixed_xor[i%len(mixed_xor)] for i in mixed_and]) class Challenge(): def __init__(self): self.</description>
    </item>
    <item>
      <title>9-invariant</title>
      <link>https://yoavshah.github.io/cryptohack/hashes/9-invariant/</link>
      <pubDate>Fri, 10 May 2024 00:00:00 +0000</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/hashes/9-invariant/</guid>
      <description>Challenge In this challenge we get another custom hash function, this time we need to find the data that makes this hash produce zero block.&#xA;import itertools import json from hashlib import sha512 FLAG = &amp;#34;crypto{????????????????????????????????}&amp;#34; class MyCipher: __NR = 31 __SB = [13, 14, 0, 1, 5, 10, 7, 6, 11, 3, 9, 12, 15, 8, 2, 4] __SR = [0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12, 1, 6, 11] def __init__(self, key): self.</description>
    </item>
    <item>
      <title>16-beatboxer</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/16-beatboxer/</link>
      <pubDate>Wed, 08 May 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/16-beatboxer/</guid>
      <description>Challenge In this challenge we get a remote program, that lets us to encrypt a message once and get the encrypted flag, nothing else. We need to use this functionality to find the flag.&#xA;#!/usr/bin/env python3 from os import urandom from utils import listener FLAG = b&amp;#39;crypto{????????????????????????????}&amp;#39; class AES: sbox = ( 0x2a, 0x00, 0x7e, 0x54, 0x82, 0xa8, 0xd6, 0xfc, 0x61, 0x4b, 0x35, 0x1f, 0xc9, 0xe3, 0x9d, 0xb7, 0xbc, 0x96, 0xe8, 0xc2, 0x14, 0x3e, 0x40, 0x6a, 0xf7, 0xdd, 0xa3, 0x89, 0x5f, 0x75, 0x0b, 0x21, 0x1d, 0x37, 0x49, 0x63, 0xb5, 0x9f, 0xe1, 0xcb, 0x56, 0x7c, 0x02, 0x28, 0xfe, 0xd4, 0xaa, 0x80, 0x8b, 0xa1, 0xdf, 0xf5, 0x23, 0x09, 0x77, 0x5d, 0xc0, 0xea, 0x94, 0xbe, 0x68, 0x42, 0x3c, 0x16, 0x44, 0x6e, 0x10, 0x3a, 0xec, 0xc6, 0xb8, 0x92, 0x0f, 0x25, 0x5b, 0x71, 0xa7, 0x8d, 0xf3, 0xd9, 0xd2, 0xf8, 0x86, 0xac, 0x7a, 0x50, 0x2e, 0x04, 0x99, 0xb3, 0xcd, 0xe7, 0x31, 0x1b, 0x65, 0x4f, 0x73, 0x59, 0x27, 0x0d, 0xdb, 0xf1, 0x8f, 0xa5, 0x38, 0x12, 0x6c, 0x46, 0x90, 0xba, 0xc4, 0xee, 0xe5, 0xcf, 0xb1, 0x9b, 0x4d, 0x67, 0x19, 0x33, 0xae, 0x84, 0xfa, 0xd0, 0x06, 0x2c, 0x52, 0x78, 0xf6, 0xdc, 0xa2, 0x88, 0x5e, 0x74, 0x0a, 0x20, 0xbd, 0x97, 0xe9, 0xc3, 0x15, 0x3f, 0x41, 0x6b, 0x60, 0x4a, 0x34, 0x1e, 0xc8, 0xe2, 0x9c, 0xb6, 0x2b, 0x01, 0x7f, 0x55, 0x83, 0xa9, 0xd7, 0xfd, 0xc1, 0xeb, 0x95, 0xbf, 0x69, 0x43, 0x3d, 0x17, 0x8a, 0xa0, 0xde, 0xf4, 0x22, 0x08, 0x76, 0x5c, 0x57, 0x7d, 0x03, 0x29, 0xff, 0xd5, 0xab, 0x81, 0x1c, 0x36, 0x48, 0x62, 0xb4, 0x9e, 0xe0, 0xca, 0x98, 0xb2, 0xcc, 0xe6, 0x30, 0x1a, 0x64, 0x4e, 0xd3, 0xf9, 0x87, 0xad, 0x7b, 0x51, 0x2f, 0x05, 0x0e, 0x24, 0x5a, 0x70, 0xa6, 0x8c, 0xf2, 0xd8, 0x45, 0x6f, 0x11, 0x3b, 0xed, 0xc7, 0xb9, 0x93, 0xaf, 0x85, 0xfb, 0xd1, 0x07, 0x2d, 0x53, 0x79, 0xe4, 0xce, 0xb0, 0x9a, 0x4c, 0x66, 0x18, 0x32, 0x39, 0x13, 0x6d, 0x47, 0x91, 0xbb, 0xc5, 0xef, 0x72, 0x58, 0x26, 0x0c, 0xda, 0xf0, 0x8e, 0xa4 ) rcon = (0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36) gmul2 = ( 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65, 0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5 ) gmul3 = ( 0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11, 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71, 0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41, 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1, 0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1, 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a, 0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba, 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda, 0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a, 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a, 0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a ) def __init__(self, key): self.</description>
    </item>
    <item>
      <title>15-forbidden_fruit</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/15-forbidden_fruit/</link>
      <pubDate>Mon, 06 May 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/15-forbidden_fruit/</guid>
      <description>Challenge In this challenge we get a program that let&amp;rsquo;s us encrypt and decrypt values using AES-GCM. To get the flag we need to encrypt the string &amp;ldquo;give me the flag&amp;rdquo; and send it to the decrypt function with the appropriate $tag$, the problem is that in the encryption method, if the string &amp;ldquo;flag&amp;rdquo; is inside the plaintext the program will refuse signing our message!&#xA;from Crypto.Cipher import AES import os IV = ?</description>
    </item>
    <item>
      <title>14-paper_plane</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/14-paper_plane/</link>
      <pubDate>Tue, 30 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/14-paper_plane/</guid>
      <description>Challenge In this challenge we get a program that has a method which gives us the encrypted flag in AES IGE mode. We also have a decrypt method which decrypts the message and return message recieved or an error - meaning we can&amp;rsquo;t just use the decrypt function!&#xA;from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad import os KEY = ? FLAG = ? class AesIge: def __init__(self, key): self.</description>
    </item>
    <item>
      <title>13-oh-snap</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/13-oh-snap/</link>
      <pubDate>Sun, 28 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/13-oh-snap/</guid>
      <description>Challenge This challenge was quite hard. In this challenge we get a little program that receives a ciphertext and a $nonce$, then creates a new ARC4 encryption class that its key is equal to the $nonce$ concat with the $flag$, and then decrypts the ciphertext with it. We need using some magic to get the flag (which is part of the key).&#xA;from Crypto.Cipher import ARC4 FLAG = ? @chal.route(&amp;#39;/oh_snap/send_cmd/&amp;lt;ciphertext&amp;gt;/&amp;lt;nonce&amp;gt;/&amp;#39;) def send_cmd(ciphertext, nonce): if not ciphertext: return {&amp;#34;error&amp;#34;: &amp;#34;You must specify a ciphertext&amp;#34;} if not nonce: return {&amp;#34;error&amp;#34;: &amp;#34;You must specify a nonce&amp;#34;} ciphertext = bytes.</description>
    </item>
    <item>
      <title>01-passwords_as_keys</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/01-passwords_as_keys/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/01-passwords_as_keys/</guid>
      <description>Challenge from Crypto.Cipher import AES import hashlib import random # /usr/share/dict/words from # https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words with open(&amp;#34;/usr/share/dict/words&amp;#34;) as f: words = [w.strip() for w in f.readlines()] keyword = random.choice(words) KEY = hashlib.md5(keyword.encode()).digest() FLAG = ? @chal.route(&amp;#39;/passwords_as_keys/decrypt/&amp;lt;ciphertext&amp;gt;/&amp;lt;password_hash&amp;gt;/&amp;#39;) def decrypt(ciphertext, password_hash): ciphertext = bytes.fromhex(ciphertext) key = bytes.fromhex(password_hash) cipher = AES.new(key, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {&amp;#34;error&amp;#34;: str(e)} return {&amp;#34;plaintext&amp;#34;: decrypted.hex()} @chal.route(&amp;#39;/passwords_as_keys/encrypt_flag/&amp;#39;) def encrypt_flag(): cipher = AES.new(KEY, AES.MODE_ECB) encrypted = cipher.</description>
    </item>
    <item>
      <title>02-ecbcbcwtf</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/02-ecbcbcwtf/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/02-ecbcbcwtf/</guid>
      <description>Challenge This is another easy challenge we get the encrypted flag in CBC (+ its random IV) mode, but we can decrypt only in ECB mode&#xA;from Crypto.Cipher import AES KEY = ? FLAG = ? @chal.route(&amp;#39;/ecbcbcwtf/decrypt/&amp;lt;ciphertext&amp;gt;/&amp;#39;) def decrypt(ciphertext): ciphertext = bytes.fromhex(ciphertext) cipher = AES.new(KEY, AES.MODE_ECB) try: decrypted = cipher.decrypt(ciphertext) except ValueError as e: return {&amp;#34;error&amp;#34;: str(e)} return {&amp;#34;plaintext&amp;#34;: decrypted.hex()} @chal.route(&amp;#39;/ecbcbcwtf/encrypt_flag/&amp;#39;) def encrypt_flag(): iv = os.urandom(16) cipher = AES.new(KEY, AES.MODE_CBC, iv) encrypted = cipher.</description>
    </item>
    <item>
      <title>03-ecb_oracle</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/03-ecb_oracle/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/03-ecb_oracle/</guid>
      <description>Challenge This is an interesting challenge, in this challenge we can send data to the program and the program then returns the encrypted(data + flag) with ECB mode&#xA;from Crypto.Cipher import AES from Crypto.Util.Padding import pad, unpad KEY = ? FLAG = ? @chal.route(&amp;#39;/ecb_oracle/encrypt/&amp;lt;plaintext&amp;gt;/&amp;#39;) def encrypt(plaintext): plaintext = bytes.fromhex(plaintext) padded = pad(plaintext + FLAG.encode(), 16) cipher = AES.new(KEY, AES.MODE_ECB) try: encrypted = cipher.encrypt(padded) except ValueError as e: return {&amp;#34;error&amp;#34;: str(e)} return {&amp;#34;ciphertext&amp;#34;: encrypted.</description>
    </item>
    <item>
      <title>04-flipping_cookie</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/04-flipping_cookie/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/04-flipping_cookie/</guid>
      <description>Challenge In this challenge we get a data encrypted with CBC mode and its randomized IV. To get the flag for this challenge we need to use the check_admin method, but use a cookie and an IV that will make the program think we has the string &amp;ldquo;admin=True;&amp;rdquo; instead of &amp;ldquo;admin=False;&amp;rdquo; (As generated in our cookie)&#xA;from Crypto.Cipher import AES import os from Crypto.Util.Padding import pad, unpad from datetime import datetime, timedelta KEY = ?</description>
    </item>
    <item>
      <title>05-lazy_cbc</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/05-lazy_cbc/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/05-lazy_cbc/</guid>
      <description>Challenge In this challenge we get a program of a lazy developer whom used the KEY also as an IV, we can use the encrypt method which encrypts the data and the receive method which decrypt the data and returns it only if the data is not textual (we can force it to not be textual)&#xA;from Crypto.Cipher import AES KEY = ? FLAG = ? @chal.route(&amp;#39;/lazy_cbc/encrypt/&amp;lt;plaintext&amp;gt;/&amp;#39;) def encrypt(plaintext): plaintext = bytes.</description>
    </item>
    <item>
      <title>06-triple_des</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/06-triple_des/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/06-triple_des/</guid>
      <description>Challenge In this challenge we get a program that can encrypt any plaintext with a chosen key, and also can encrypt the flag with a chosen key. We can&amp;rsquo;t reproduce the decryption routine in our computer, because we don&amp;rsquo;t have access to the generated IV.&#xA;Remember we also can&amp;rsquo;t just take the encrypted flag and put it in the encrypt method because the DES encryption block and the DES decryption block are not the same (Or are they ?</description>
    </item>
    <item>
      <title>07-symmetry</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/07-symmetry/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/07-symmetry/</guid>
      <description>Challenge This is actually an easy challenge, we can get the encrypted flag with a random IV and an unknown KEY in OFB mode using the encrypt_flag routine, and also we can encrypt data with a chosen IV and an unknown KEY in OFB mode&#xA;from Crypto.Cipher import AES KEY = ? FLAG = ? @chal.route(&amp;#39;/symmetry/encrypt/&amp;lt;plaintext&amp;gt;/&amp;lt;iv&amp;gt;/&amp;#39;) def encrypt(plaintext, iv): plaintext = bytes.fromhex(plaintext) iv = bytes.fromhex(iv) if len(iv) != 16: return {&amp;#34;error&amp;#34;: &amp;#34;IV length must be 16&amp;#34;} cipher = AES.</description>
    </item>
    <item>
      <title>08-bean_counter</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/08-bean_counter/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/08-bean_counter/</guid>
      <description>Challenge In this challenge we get a program that its developer tried to create his own implementation to CTR mode (using the ECB mode)&#xA;from Crypto.Cipher import AES KEY = ? class StepUpCounter(object): def __init__(self, step_up=False): self.value = os.urandom(16).hex() self.step = 1 self.stup = step_up def increment(self): if self.stup: self.newIV = hex(int(self.value, 16) + self.step) else: self.newIV = hex(int(self.value, 16) - self.stup) self.value = self.newIV[2:len(self.newIV)] return bytes.fromhex(self.value.zfill(32)) def __repr__(self): self.increment() return self.</description>
    </item>
    <item>
      <title>09-ctrime</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/09-ctrime/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/09-ctrime/</guid>
      <description>Challenge I really enjoyed this challenge. In this challenge we get a program with the method encrypt which receives a plaintext, concat it with the flag, compress it with zlib and encrypt it with AES CTR mode (which is not actually a block cipher) We need to get the flag.&#xA;from Crypto.Cipher import AES from Crypto.Util import Counter import zlib KEY = ? FLAG = ? @chal.route(&amp;#39;/ctrime/encrypt/&amp;lt;plaintext&amp;gt;/&amp;#39;) def encrypt(plaintext): plaintext = bytes.</description>
    </item>
    <item>
      <title>10-logon_zero</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/10-logon_zero/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/10-logon_zero/</guid>
      <description>Challenge In this challenge we get a remote server with a code call 13399.py&#xA;The remote server support 3 method&#xA;authenticate - if the password we sent equals to the password of the challenge we ge tthe flag reset_connection - create a new CFB8 cipher with random input reset_password - it decrypt the token and get a size from the last 4 bytes, then creates a random password in that length #!</description>
    </item>
    <item>
      <title>11-stream_consciousness</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/11-stream_consciousness/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/11-stream_consciousness/</guid>
      <description>Challenge In this challenge we get a program that has encrypt routine and when execute it will choose random text contant, encrypt it with CTR (without any prefix, suffix, and initial value 0) with an unknown KEY.&#xA;We need to decrypt the flag somehow&#xA;from Crypto.Cipher import AES from Crypto.Util import Counter import random KEY = ? TEXT = [&amp;#39;???&amp;#39;, &amp;#39;???&amp;#39;, ..., FLAG] @chal.route(&amp;#39;/stream_consciousness/encrypt/&amp;#39;) def encrypt(): random_line = random.choice(TEXT) cipher = AES.</description>
    </item>
    <item>
      <title>12-dancing_queen</title>
      <link>https://yoavshah.github.io/cryptohack/symmetric/12-dancing_queen/</link>
      <pubDate>Fri, 26 Apr 2024 10:59:55 +0300</pubDate>
      <guid>https://yoavshah.github.io/cryptohack/symmetric/12-dancing_queen/</guid>
      <description>Challenge In this challenge we get a python code named &amp;ldquo;chacha20.py&amp;rdquo; and the output of the code &amp;ldquo;output.txt&amp;rdquo;. In the &amp;ldquo;chacha20.py&amp;rdquo; code the programmer created a randomized unknown key, randomized known iv1 (from the output.txt file), randomized iv2(from the output.txt file).&#xA;The programmer also encrypt the flag using iv1 and the key, we have access to enc_flag.&#xA;And also we have access to msg and enc_msg.&#xA;#!/usr/bin/env python3 from os import urandom FLAG = b&amp;#39;crypto{?</description>
    </item>
  </channel>
</rss>
